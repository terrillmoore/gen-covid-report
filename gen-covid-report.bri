/*

Module:  gen-covid-report.bri

Function:
	Set up a COVID-19 report

Copyright notice:
	See accompanying license file.

Author:
	Terry Moore, MCCI Corporation	August 2016

Running:
    MCCIBRIGHT_LIB=c:/tools/lib/bright bright gen-covid-report.bri ../COVID-19

*/

/*
|| The version number
*/
if (!(.VERSION in globals()))
	VERSION = "v0.1.0";
if (!(.COPYRIGHT in globals()))
	COPYRIGHT = "Copyright (C) 2020, MCCI Corporation";

/*
|| Load MCCI Bright Library -- This can come from environment MCCIBRIGHT_LIB
|| (conforming to the Windows MCCIConf naming conventions).
||
|| Also compatible with the library existing in the current directory or
|| already loaded.
*/
if(!(.Lib in globals()))
	{
	local BRIGHTLIB = getenv("MCCIBRIGHT_LIB");
	local MCCIBRIGHTLIB_root = (BRIGHTLIB == NULL ? "" : BRIGHTLIB .. "/") .. "mcci_v1.br"
	// try compiled form
	local tLib, sError = dofile(MCCIBRIGHTLIB_root .. "o");
	if (sError != NULL)
		{
		tLib, sError = dofile(MCCIBRIGHTLIB_root.."i");
		if (sError != NULL)
	    		{
	    		assert(FALSE,
				"mcci_v1.bri not found/readable: " .. sError .. ". "..
				" Set MCCIBRIGHT_LIB to the directory."
				);
			}
	    	}
	assert(Lib != NULL, "mcci_v1.bri load failed!")
	}

{
local kBreak = Lib.ParsedDateToPosix(Lib.ParseDateString("2020-03-10"));
gvDates = {};

function SanitizeUS(tData, sProvince, posixDate)
    {
    if (posixDate < %kBreak)
        return TRUE;
    if (sProvince in tData.tProvinceMap)
        return TRUE;
    else
        return FALSE;
    }
}

gData = 
    {
    US = { name="US", pop = 330e6, hospital_beds_per_k = 2.9, tProvinceMap = {}, Sanitize = SanitizeUS, },
    KR = { name="Korea, South", pop = 51e6, hospital_beds_per_k = 11.5,  },
    CN = { name="China", pop = 1.1e9, },
    IT = { name="Italy", pop = 62e6, },
    NO = { name="Norway", pop = 5.2e6, },
    ES = { name="Spain", pop = 46.42e6, },
    FR = { name="France", pop = 66.9e6, },
    DE = { name="Germany", pop = 82.93e6, },
    IN = { name="India", pop = 1.35e9 },
    JP = { name="Japan", pop = 126.79e6 },
    EC = { name="Ecuador", pop = 17.08e6 },
    };

{
    local USstates =
        {
        "Alabama",
        "Alaska",
        "Arizona",
        "Arkansas",
        "California",
        "Colorado",
        "Columbia",
        "Connecticut",
        "Delaware",
        "Florida",
        "Georgia",
        "Guam",
        "Hawaii",
        "Idaho",
        "Illinois",
        "Indiana",
        "Iowa",
        "Kansas",
        "Kentucky",
        "Louisiana",
        "Maine",
        "Maryland",
        "Massachusetts ",
        "Michigan",
        "Minnesota",
        "Mississippi",
        "Missouri",
        "Montana",
        "Nebraska",
        "Nevada",
        "New Hampshire",
        "New Jersey",
        "New Mexico",
        "New York",
        "North Carolina",
        "North Dakota",
        "Northern Marianas Islands",
        "Ohio",
        "Oklahoma",
        "Oregon",
        "Pennsylvania",
        "Puerto Rico",
        "Rhode Island",
        "Samoa",
        "South Carolina",
        "South Dakota",
        "Tennessee",
        "Texas",
        "Utah",
        "Vermont",
        "Virgin Islands",
        "Virginia",
        "Washington",
        "West Virginia",
        "Wisconsin",
        "Wyoming",
        };
    local USStateMap = Lib.Transpose(USstates);
    gData.US.tProvinceMap = USStateMap
}

{
    gCountryMap = {};

    for k, v in gData do
        {
        gCountryMap[v.name] = k;
        }
}

/****************************************************************************\
|
|	main()
|
\****************************************************************************/

function loadfile(sPrefix, sFrag)
    {
    // open the file
    local f, e = openfile(format("%scsse_covid_19_data/csse_covid_19_time_series/time_series_19-covid-%s.csv", sPrefix, sFrag), "r");

    if (f == NULL)
        %Lib.Fatal("Can't open file fragment %s", sFrag);

    local s, e1 = read(f, "*a");
    if (s == NULL)
        %Lib.Fatal("Can't read file fragment %s", sFrag);

    closefile(f);

    // normalize dates
    local s1 = gsub(s,
            "(%d+)/(%d+)/(%d%d)",
            function(m,d,y) 
                { 
                return format("20%02s-%02s-%02s", y, m, d); 
                });

    // parse CSV, return headers as line 1
    local t = %Lib.ParseCsv(s1, {});
    return t;
    }


function main(tArgs)
    {
    local sPrefix = tArgs[1];
    local nLast = getn(tArgs) > 2 ? Lib.StringToNumber(tArgs[2]) : NULL;
    local tConfirmed = loadfile(sPrefix, "Confirmed");
    local tDeaths = loadfile(sPrefix, "Deaths");
    local tRecovered = loadfile(sPrefix, "Recovered");
    local tMerge = {};
    local sProvince = "Province/State"; local kProvince = 0;
    local sCountry = "Country/Region"; local kCountry = 1;
    local sLat = "Lat"; local kLat = 2;
    local sLong = "Long"; local kLong = 3;
    gkDate = 4;

    // build a date translation table
    gtHeader = tConfirmed[0]; 
    local tDates;
    local vDates = {}
    gvDates = vDates;

    for i = gkDate, getn(gtHeader)-1 do
        {
        tinsert(vDates, %Lib.ParsedDateToPosix(%Lib.ParseDateString(gtHeader[i])));
        }

    local initDataTable = function() 
        {
        local tData = {}
        local tResult = { Total = { Data = tData } };
        for i = gkDate, getn(gtHeader) - 1 do
            {
            tData[i - gkDate] = 
                {
                Confirmed = 0,
                Deaths = 0,
                Recovered = 0,
                };
            }
        return tResult;
        }
    
    tMerge.World = initDataTable();

    // merge 3 tables
    for iRow = 1, getn(tConfirmed) - 1 do
        {
        local trConfirmed = tConfirmed[iRow];
        local trDeaths = tDeaths[iRow];
        local trRecovered = tRecovered[iRow];
        local trMerge = {};
        local fSkip = FALSE;
       
        local sCountry = trConfirmed[kCountry];
        local sProvince = trConfirmed[kProvince];
        local tCountryData;

        if (sCountry in gCountryMap)
            {
            tCountryData = gData[gCountryMap[sCountry]];
            }
        else
            tCountryData = {};

        local tWorldData = tMerge.World.Total.Data;

        if (! fSkip)
            {
            if ( ! (sCountry in tMerge))
                {
                tMerge[sCountry] = initDataTable();
                }

            local tTotalData = tMerge[sCountry].Total.Data;

            tMerge[sCountry][sProvince] =
                    {
                    GPS = { Lat = %Lib.StringToNumber(trConfirmed[kLat]), 
                            Long = %Lib.StringToNumber(trConfirmed[kLong]) },
                    Data = {}
                    };

            tMerge[sCountry][sProvince].Data = trMerge;

            for i = gkDate, getn(trConfirmed)-1 do
                {
                local posixDate = vDates[i - gkDate];

                local v = { Confirmed = %Lib.StringToNumber(trConfirmed[i]),
                            Deaths = %Lib.StringToNumber(trDeaths[i]),
                            Recovered = %Lib.StringToNumber(trRecovered[i])
                        };
                tinsert(trMerge, v);

                if (.Sanitize in tCountryData && ! tCountryData.Sanitize(tCountryData, sProvince, posixDate))
                    {
                    /* do nothing */;
                    // print("skip "..sProvince);
                    }
                else
                    {
                    addStats(tTotalData[i - gkDate], v);
                    addStats(tWorldData[i - gkDate], v);
                    }
                }
            }
        }

    write("# COVID-19 Report from `gen-covid-report`\n")
    write("\n");

    reportCases(gData.KR, tMerge, vDates, nLast);
    reportCases(gData.US, tMerge, vDates, nLast);
    reportCases(gData.IT, tMerge, vDates, nLast);
    reportCases(gData.NO, tMerge, vDates, nLast);
    reportCases(gData.ES, tMerge, vDates, nLast);
    reportCases(gData.FR, tMerge, vDates, nLast);
    reportCases(gData.DE, tMerge, vDates, nLast);
    reportCases(gData.IN, tMerge, vDates, nLast);
    reportCases(gData.JP, tMerge, vDates, nLast);
    reportCases(gData.EC, tMerge, vDates, nLast);

    // use the most recent korean total as the average rate 
    local tKRlast = getKRlast(tMerge);
    local rateKR = tKRlast.Deaths / tKRlast.Confirmed;
    local tWorld = tMerge.World.Total.Data;
    local firstI = nLast == NULL || nLast == 0 ? 0 : getn(tWorld) - nLast;

    // print out general info
    write("\n");
    write("## World cases (outside China)\n")
    write("\n");
    write(format(
          "|  Date  |  Confirmed |  Deaths | Rate (%s) | KR Normalized | Doubling Days |\n", "%"));
    write("|:------:|:----------:|:-------:|:---------:|:-------------:|:-------------:|\n");
    local kLog2 = log(2);
    local doublingSum = 0;
    local doublingCount = 0;
    for i = firstI, getn(tWorld)-1 do
        {
        local tThis = tWorld[i];
        local sDate = date("%Y-%m-%d", "utc", vDates[i]);
        local nNew, nNewPrev = 0, 0;
        local tCn = tMerge[gData.CN.name].Total.Data;
        local tThisCn = tCn[i];
        local nConfirmed = tThis.Confirmed - tThisCn.Confirmed;
        local nDeaths = tThis.Deaths - tThisCn.Deaths;

        nNew = nConfirmed;
        if (i > 0)
            nNewPrev = (tWorld[i-1].Confirmed - tCn[i-1].Confirmed);

        if (nNewPrev > 0)
            nDoubling = kLog2 / log(nNew / nNewPrev);

        local nConfirmedAdjust = nDeaths / rateKR;

        write(format(
            "| %s | %d | %d | %.2f | %d | %.1f |\n",
            sDate,
            nConfirmed,
            nDeaths,
            nConfirmed != 0 ? nDeaths / nConfirmed * 100 : 0,
            nConfirmedAdjust,
            nDoubling
            ));

        doublingSum = doublingSum + nDoubling;
        if (nDoubling != 0)
            doublingCount = doublingCount + 1;
        }

    if (doublingCount != 0)
        {
        write("\n");
        write(format("Mean doubling days: %.1f\n", doublingSum/doublingCount));
        }
    }

function addStats(t1, t2)
    {
    t1.Confirmed = t1.Confirmed + t2.Confirmed;
    t1.Deaths = t1.Deaths + t2.Deaths;
    t1.Recovered = t1.Recovered + t2.Recovered;
    return t1;
    }

function getKRlast(tMerge)
    {
    local iLast = getn(gtHeader)-gkDate-1;
    local tKRlast = tMerge[gData.KR.name].Total.Data[iLast];
    if (tKRlast.Deaths == 0)
        tKRlast = tMerge[gData.KR.name].Total.Data[iLast - 1];
    return tKRlast;    
    }

function formatPopPerCase(pop, nCases)
    {
    local n = NULL;
    if (pop != NULL && nCases != NULL && nCases != 0)
        n = pop / nCases;

    return formatHeadcount(n);
    }

function formatHeadcount(n)
    {
    local sResult = "-";
    if (n != NULL)
        {
        if (n < 1e6)
            {
            sResult = format("%d", n);
            if (strlen(sResult) > 3)
                sResult = strsub(sResult, 0, -4)..","..strsub(sResult, -3);
            }
        else if (n < 1e9)
            sResult = format("%.1fe6", n / 1e6);
        else
            sResult = format("%.1fe9", n / 1e9);
        }
    return sResult;
    }

function reportCases(tCountryData, tMerge, vDates, nLast)
    {
    // tMerge[] has the data. Get the US total for today
    local iLast = getn(gtHeader)-gkDate-1;
    local tCountrylast = tMerge[tCountryData.name].Total.Data[iLast];
    local tKRlast = getKRlast(tMerge);
    local tWorld = tMerge.World.Total.Data
    local tWorldLast = tWorld[iLast];
    local kLog2 = log(2);
    
    write(format("## %s Cases (Reported and Inferred)\n", tCountryData.name));
    write("\n");
    write(format("| Date | Confirmed | Deaths | Pop/Confirmed | Doubling | Deaths (%s) | KR Deaths (%s) | Inferred Cases | Pop/Inferred |\n",
                "%", "%"));
    write(format("|:----:|:---------:|:------:|:-------------:|:--------:|:-----------:|:--------------:|:---------------:|:----------:|\n"));
    local tCountry = tMerge[tCountryData.name].Total.Data;
    local tKR = tMerge[gData.KR.name].Total.Data;
    local firstI = nLast == NULL || nLast == 0 ? 0 : getn(tCountry) - nLast;

    for i = firstI, getn(tCountry)-1 do
        {
        local tThis = tCountry[i];
        local tRateKR;
        if (tKR[i].Confirmed == 0)
            tRateKR = tKRlast.Deaths / tKRlast.Confirmed;
        else
            tRateKR = tKR[i].Deaths / tKR[i].Confirmed;
        local sDate = date("%Y-%m-%d", "utc", vDates[i]);
        local rateHere = tThis.Confirmed != 0 ? tThis.Deaths / tThis.Confirmed : 0;

        local nNew = tThis.Confirmed;
        local nNewPrev = NULL;
        local nDoubling = NULL;
        if (i > 0)
            nNewPrev = tCountry[i-1].Confirmed;

        if (nNewPrev != NULL && nNewPrev > 0 && nNew > nNewPrev)
            nDoubling = kLog2 / log(nNew / nNewPrev);

        local sPopPerCase = formatPopPerCase(tCountryData.pop, nNew);

        local sDoubling = (nDoubling == NULL) ? "- " : format("%.1f", nDoubling);

        local nInferred = tRateKR != 0 ? tThis.Deaths / tRateKR : tThis.Deaths;

        if (rateHere <= tRateKR)
            {
            nInferred = NULL;
            }

        local sLine = 
            format("| %s | %s | %s | %s | %s | %.2f | %.2f | %s | %s |\n", 
                    sDate, 
                    formatHeadcount(tThis.Confirmed), 
                    formatHeadcount(tThis.Deaths),
                    sPopPerCase, 
                    sDoubling,
                    rateHere * 100,
                    tRateKR * 100,
                    formatHeadcount(nInferred),
                    formatPopPerCase(tCountryData.pop, nInferred)
                    );

        write(sLine);
        }
    }
